---
---
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Undercovidreams</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/queue.v1.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link type="text/css" rel="stylesheet" href="assets/css/main.css">
    <link type="text/css" rel="stylesheet" href="assets/css/spin.css">
  </head>
  <body>
    <div id="about" class="panel">
      <h3>Undercovidreams</h3>      
      <p>
        I risvegli lenti riportano alla mente i sogni.
        In questi giorni insoliti, ti chiediamo di condividere i tuoi.
      </p>
    </div>
    <div id="controls" class="panel">
      <i id="playbutton" class="material-icons clickable">play_arrow</i>
      <i id="pausebutton" class="material-icons clickable">pause</i>
    </div>
    <div id="info" class="panel">
      <span class="material-icons clickable">info</span>
    </div>    
    <div id="intro">
      <div>
        <span class="material-icons" style="font-size: 100px">zoom_out_map</span>
      </div>
    </div>
    <div id="backbutton">
        <span class="material-icons">arrow_back_ios</span>
    </div>
    
    <script type="module">
      
      import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';      
      import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
      import { CSS3DRenderer, CSS3DObject } from "https://threejs.org/examples/jsm/renderers/CSS3DRenderer.js";
      import { TWEEN} from "https://threejs.org/examples/jsm/libs/tween.module.min.js";

      import {Spinner} from './assets/js/spin.js';
var opts = {
  lines: 13, // The number of lines to draw
  length: 5, // The length of each line
  width: 7, // The line thickness
  radius: 27, // The radius of the inner circle
  scale: 1.1, // Scales overall size of the spinner
  corners: 0, // Corner roundness (0..1)
  speed: 1, // Rounds per second
  rotate: 0, // The rotation offset
  animation: 'spinner-line-fade-quick', // The CSS animation name for the lines
  direction: 1, // 1: clockwise, -1: counterclockwise
  color: '#ffffff', // CSS color or array of colors
  fadeColor: 'transparent', // CSS color or array of colors
  top: '50%', // Top position relative to parent
  left: '50%', // Left position relative to parent
  shadow: '0 0 1px transparent', // Box-shadow for the lines
  zIndex: 2000000000, // The z-index (defaults to 2e9)
  className: 'spinner', // The CSS class to assign to the spinner
  position: 'absolute', // Element positioning
};

var target = document.getElementsByTagName('body')[0];
var spinner = new Spinner(opts).spin(target);
      
      /* if controls are enabled. disabled in the beginning and during tweens to avoid tweens overlapping and other mess */
      var enabled_controls = false;
      /* if we are still in the intro. it lasts until the distance of the camera from the center is below the intro_distance_threshold */
      var intro = true;
      var intro_distance_threshold = 400;
      var words={};
      /* selected_dream is the dream we are currently looking and listening to. if there's any */
      /* focused_dream is the dream, if any, currently below the mouse cursor */
      var selected_dream, focused_dream;

      /*three.js components*/
      let camera, controls, scene, renderer, renderer2;
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      
      var dreams_opacity = 0.1;
      var sphere_radius = 2;

      /* loading multiple json files in parallel, ie. using a queue of size = 2 */
      queue(2)
    .defer(d3.json, "assets/data/words.json")
    .defer(d3.json, "assets/data/dreams.json")
    .awaitAll(function(error, data) {
        if (error)
            throw error;
        $("#intro").show();
        $("#info").show();
        init(data[0], data[1]);
    });
      
           
      function init(words_data, dreams_data) {
          const scene = new THREE.Scene();
          
          const renderer = new THREE.WebGLRenderer({antialias: false});
          const container = document.createElement('div');
          document.body.appendChild(container);
          container.appendChild( renderer.domElement );
          
          renderer2 = new CSS3DRenderer();
		      renderer2.domElement.style.position = 'absolute';
		      renderer2.domElement.style.top = 0;
		      container.appendChild( renderer2.domElement );
          
          /* camera */
          const camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 20000 );
          camera.position.set( -200, -500, 300 );
          camera.lookAt( 0, 0, 0 );
          /* camera */
          
          /* controls */
          const controls = new OrbitControls( camera, renderer2.domElement );
          controls.listenToKeyEvents(window);
          controls.autoRotate = true;
          controls.autoRotateSpeed = -0.2;
		      controls.enableDamping = true;
		      controls.dampingFactor = 1;
          
		      controls.minDistance = 0;
		      controls.maxDistance = 2000;
          
		      controls.maxPolarAngle = Math.PI/2;

          onWindowResize();
          window.addEventListener( 'resize', onWindowResize, false );

          controls.update();
          /* controls */
          
          const xscale=5;
          const yscale=5;
          const zscale=10;
          
          /* words data */

          words_data.forEach(function(d) {
              if (d[0] in words)
                  words[d[0]]["num"]++;
              else
                  words[d[0]]={
                      "x":d[1][0]*xscale,
                      "y":d[1][1]*yscale,
                      "z":d[1][2]*zscale,
                      "num":0
                  }
          });
          
          const vertices = [];
          const VERTNUM=Object.keys(words).length;
          const loader = new THREE.TextureLoader();
          for (const [k, w] of Object.entries(words)) {
              vertices.push(w["x"],w["y"],w["z"]);
              
              /* DIV word object*/
              const word = document.createElement('div');
              word.className = 'word';
              word.textContent= k;
              const objectCSS = new CSS3DObject(word);
              objectCSS.position.x = w["x"];
				      objectCSS.position.y = w["y"]+1;
				      objectCSS.position.z = w["z"];
              const min=3;
              const alpha=0.01*min+0.01*Math.max(0,(w["num"]-min));              
              objectCSS.scaledColor="rgba(150,140,130,"+alpha+")";
              objectCSS.absoluteColor="rgba(150,140,130,0.6)";
              objectCSS.alpha=alpha;
              objectCSS.element.style.color=objectCSS.scaledColor;
				      scene.add( objectCSS );
              w["wordobject"]=objectCSS;
              
              /* start point */
              const geometry = new THREE.BufferGeometry();
              geometry.setAttribute( 'position', new THREE.Float32BufferAttribute([w["x"], w["y"], w["z"]], 3));
              const wordsprite = loader.load("assets/data/word.png");
              const material = new THREE.PointsMaterial({size: 1, map: wordsprite, transparent: true, blending: THREE.AdditiveBlending, depthTest: false});            
              const star = new THREE.Points( geometry, material );
              scene.add( star );              
              w["starobject"]=star;
          }
          
          /* dreams */
          
          var center=[0,0,0];
          var dreams=[]; //general infos
          var dreams_points=[]; // scene points
          dreams_data.forEach(function(d){
              const info={};
              dreams.push(info);
              info["coords"]=[d["coords"][0]*xscale,d["coords"][1]*yscale,d["coords"][2]*zscale];
              center[0]+=d["coords"][0]*xscale;
              center[1]+=d["coords"][1]*yscale;
              center[2]+=d["coords"][2]*zscale;
              if (d["audio"]=="")
                  info["audiofile"]="test.mp3";
              else
                  info["audiofile"]=d["audio"];
              // we don't need the full array!
              info["words"]=d["words"];
              const dream_geometry = new THREE.SphereGeometry(sphere_radius, 16, 16);
              var material = new THREE.MeshBasicMaterial({
                  color: 0x7FC8C8,                  
                  wireframe: true,
                  wireframeLinewidth: 0.1,
                  opacity: dreams_opacity,
                  transparent: true
              });
              //              const material = new THREE.PointsMaterial({size: 1, transparent: true, blending: THREE.AdditiveBlending, depthTest: false});                          
              //              const material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
              const dreampoint = new THREE.Mesh( dream_geometry, material );
              dreampoint.position.set(info["coords"][0], info["coords"][1], info["coords"][2]);
              //              dreampoint.scale.x=dreampoint.scale.y=dreampoint.scale.y=2;
              info["point"]=dreampoint;
              dreampoint.info=info;
              scene.add( dreampoint );
              dreams_points.push(dreampoint);
          });
          
          center[0]/=Object.keys(dreams).length;
          center[1]/=Object.keys(dreams).length;
          center[2]/=Object.keys(dreams).length;
          
          const centerVect = new THREE.Vector3(center[0], center[1], center[2]);
          
          renderer.render( scene, camera );
          renderer2.render( scene, camera );
          
          requestAnimationFrame(render);
          spinner.stop();
          
          //    alert($("#info"));
         
          
          /* audio */
          const listener = new THREE.AudioListener();
          camera.add( listener );
          const sound = new THREE.Audio( listener );

          function onWindowResize( event ) {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize( window.innerWidth, window.innerHeight );
              renderer2.setSize( window.innerWidth, window.innerHeight );              
          }
          
          function show_all_dreams() {
              enabled_controls = false;
              $("#backbutton").hide();
              const full_duration=1200;
              var tween = new TWEEN.Tween(selected_dream.scale).
                  to({x: 1, y: 1, z: 1}, full_duration).
                  easing(TWEEN.Easing.Exponential.InOut).
                  onComplete(function() {
                      enabled_controls = true;
                  }).
                  start();

              const delay=600;
              dreams_points.forEach(function(dream) {
                  if (dream!=selected_dream)
                  {
                      setTimeout(function(){
                          dream.material.opacity=0;
                          dream.visible=true;
                      }, delay);
                      new TWEEN.Tween(dream.material).
                          to({opacity: dreams_opacity}, delay).
                          delay(full_duration - delay).
                          start();
                  }
              });
              
              for (const [k, w] of Object.entries(words)) {
                  w["wordobject"].visible=true;
                  w["starobject"].visible=true;
                  w["wordobject"].element.style.color=w["wordobject"].scaledColor;
              }
              $("#controls").css("visibility", "hidden");
              sound.stop();
          }
          
          function show_selected_dream(){
              enabled_controls = false;
              $("#about").hide();
              dreams_points.forEach(function(dream) {
                  if (dream!=selected_dream)
                  {
                      dream.transparent=true;
                      const tw= new TWEEN.Tween(dream.material).
                            to({opacity:0}, 400).
                            onComplete(function() {
                                dream.visible = false;
                                //                        alert("enabling");
                            });
                      tw.start();
                  }
              });
              
              /* 
                 generating the list of words that are contained in the dream
                 and the distance from the center to the farest one.
                 the latter is needed to calculate the scaling of the sphere
              */
              const dreamwords=[];
              const coords=selected_dream.info["coords"]
              const dream_center=new THREE.Vector3(coords[0], coords[1], coords[2]);
              let farest=0;
              selected_dream.info["words"].forEach(function(w) {
                  dreamwords.push(w[1]);
                  const word_vec=new THREE.Vector3(words[w[1]]["x"],words[w[1]]["y"],words[w[1]]["z"])
                  const word_distance=word_vec.distanceTo(dream_center);
                  if ( word_distance > farest){
                      farest = word_distance;
                  }
              });
              
              /* 
                 hiding all stars/words except the ones contained in the dream 
                 and using a different color for the latter ones
              */
              setTimeout(function(){
                  for (const [k, w] of Object.entries(words)) {
                      if (!dreamwords.includes(k)) {
                          w["wordobject"].visible=false;
                          w["starobject"].visible=false;
                      }
                      else {
                          w["wordobject"].element.style.color=w["wordobject"].absoluteColor;
                      }
                  }
              }, 600);
              
              /* simple scale calculation */
              const dreamscale=(farest-sphere_radius)/sphere_radius;
              
              /* generating the animation for the scaling */
              var tween = new TWEEN.Tween(selected_dream.scale).
                  to({x: dreamscale, y: dreamscale, z: dreamscale}, 1200).
                  easing(TWEEN.Easing.Exponential.InOut).
                  onComplete(function() {
                      const audioLoader = new THREE.AudioLoader();
                      audioLoader.load("assets/data/audio/"+selected_dream.info["audiofile"], function( buffer ) {
                          sound.setBuffer( buffer );
	                        sound.setLoop( false );
	                        sound.setVolume( 1 );
                          enabled_controls = true;
                          playaudio();
                          sound.onEnded = function (){show_all_dreams()};
                      });
                      $("#backbutton").show();
                      $("#controls").css("visibility", "visible");
                      $("#pausebutton").click(function () {pauseaudio();});
                      $("#playbutton").click(function () {playaudio();});
                  }).start();

              $("#info").click(function () {
                  $("#about").toggle();
              });
              
          }

          var mouseMoved=false;
          function playaudio(){
              $("#pausebutton").addClass("in-use");
              $("#playbutton").removeClass("in-use");
              sound.play();
          }
          function pauseaudio(){
              $("#playbutton").addClass("in-use");
              $("#pausebutton").removeClass("in-use");
              sound.pause();
          }
          function handleClick() {
              if (mouseMoved) return;
//              alert(enabled_controls);
              if (!enabled_controls) return;
              var distance=centerVect.distanceTo(camera.position);
              //        alert(view_mode());
              /* single dream -> all dreams */
              if (mode() == "single") {
                  show_all_dreams();
                  selected_dream=null;
              }
              else {
                  /* all dreams -> single dream */
                  if (focused_dream) {
                      selected_dream=focused_dream;
                      show_selected_dream();
                  }
              }
              
          }
          
          function onMouseMove( event ) 
          {
	            // update the mouse variable
	            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
          }

          /* mode return what's the current running mode:
             - loading // only loader is being shown. can only go to intro
             - intro // data are shown but most interface controls are disabled. can only go to all
             - all (showing all dreams);
             - single (showing a single dream);
             - tosingle (while transitioning from all to single); 
             - toall (while transitioning from single to all);
          */
          function mode() {
              if (intro) {return "intro"; }
              if (selected_dream!=null) { return "single"; }
              if (focused_dream!=null) { return "tosingle";}
              if (selected_dream==null && focused_dream==null) {return "all";}
              alert("unknown mode");
              return "unknown";
          }

          function exploration_mode(){
              intro = false;
              enabled_controls = true;
              //              alert(enabled_controls);
              var tween = new TWEEN.Tween($("#intro").css('opacity')).to
//              $("#intro").hide();
              $("#intro").fadeTo("slow", 0, function() {
                  $("#intro").hide();
              });
              container.addEventListener( 'pointermove', e => {
                  mouseMoved=true;
                  onMouseMove(e);
              },false );
              container.addEventListener( 'pointerdown', e => {
                  mouseMoved = false;
              }, false);
              container.addEventListener( 'pointerup', e => {
                  handleClick();
              }, false );

          }
          
          function update(){
              if (mode()=="intro") {
                  const camera_distance = camera.position.distanceTo(new THREE.Vector3(0,0,0));
                  if (camera_distance<intro_distance_threshold) {
                      exploration_mode();
                  }
              }

              controls.update();
              
	            raycaster.setFromCamera( mouse, camera );        
              const intersects = raycaster.intersectObjects( dreams_points );
              
              /* we look for the dream below the coursor only when we are in the "all" mode */
              //        if (view_mode()!="all") return;

              if (intersects.length>0) {
                  focused_dream=intersects[0].object;
                  document.getElementsByTagName("body")[0].style.cursor = "pointer";
                  
              }
              else {
                  document.getElementsByTagName("body")[0].style.cursor = "default";
                  focused_dream=null;
              }
              
          }
          
          function render(time) {
              time *= 0.001;
              update();
              requestAnimationFrame(render);
              TWEEN.update();
              renderer.render( scene, camera );
				      renderer2.render( scene, camera );
              
		      }
          
      }



    </script>
	</body>
</html>
