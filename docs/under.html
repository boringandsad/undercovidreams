---
---
    <!DOCTYPE html>
    <html>
	  <head>
		<meta charset="utf-8">
		<title>Undercovidreams</title>
		<style>		body { margin: 0; }</style>
    <style>
      .word {
				font-family: Helvetica, sans-serif;
 				text-align: center;
        font-size: 6px;
				line-height: normal;
				cursor: default;
        color: rgba(127,200,200,0.1);
			}
      </style>
    </head>
	  <body>
    <script type="module">
    
      import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';      
      import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
      import { CSS3DRenderer, CSS3DObject } from "https://threejs.org/examples/jsm/renderers/CSS3DRenderer.js";

      function scale(from_min, from_max, x, min, max) {
          return min+(max-min)*(x/(from_max-from_min));
      }
      
      let camera, controls, scene, renderer, renderer2;
      
      d3.json("./assets/data/words.json").then(
          function(data){
              alert(data);
              init(data);
          });

function init(data) {
    const scene = new THREE.Scene();
    const color = 0x000000;  // white
/*    const near = 10;
    const far = 500;
    scene.fog = new THREE.Fog(color, near, far);*/
    scene.fog = new THREE.FogExp2(color, 0.001);
    
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    
    renderer2 = new CSS3DRenderer();
		renderer2.setSize( window.innerWidth, window.innerHeight );
		renderer2.domElement.style.position = 'absolute';
		renderer2.domElement.style.top = 0;
		document.body.appendChild( renderer2.domElement );


    const size = 10;
    const divisions = 10;
    
//    const gridHelper = new THREE.GridHelper( size, divisions );
//    scene.add( gridHelper );
    
    const camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 15000 );
//    const controls = new OrbitControls( camera, renderer.domElement );
    
    const controls = new OrbitControls( camera, renderer2.domElement );
    controls.listenToKeyEvents(window);
    controls.autoRotate = true;
    controls.autoRotateSpeed = -0.2;
		controls.enableDamping = false; // an animation loop is required when either damping or auto-rotation are enabled
		controls.dampingFactor = 0.05;
    
		controls.screenSpacePanning = false;
    
		controls.minDistance = 100;
		controls.maxDistance = 500;
    
		controls.maxPolarAngle = Math.PI / 2;
    
    camera.position.set( 0, 0, 100 );
    camera.lookAt( 0, 0, 0 );
    
    controls.update();
    const vertices = [];
    const VERTNUM=data.length;
    const xscale=5;
    const yscale=5;
    const zscale=10;

    var words={}
    data.forEach(function(d) {
        if (d in words)
            words[d]["num"]++;
        else
            words[d]={
                "x":d[1][0]*xscale,
                "y":d[1][1]*yscale,
                "z":d[1][2]*zscale,
                "word":d[0],
                "num":0
            }
    });
    for (const [k, w] of Object.entries(words)) {
        vertices.push(w["x"],w["y"],w["z"]);
        const word = document.createElement('div');
        word.className = 'word';
        word.textContent= w["word"];
        var alpha=0.01*w["num"];
        word.style.color="rgba(150,140,130,"+alpha+")";
        const objectCSS = new CSS3DObject(word);
        objectCSS.position.x = w["x"];
				objectCSS.position.y = w["y"];
				objectCSS.position.z = w["z"];
				scene.add( objectCSS );
    }
/*    data.forEach(function(d) {
        vertices.push(d[1][0]*xscale, d[1][1]*yscale, d[1][2]*zscale);
        const word = document.createElement('div');
        word.className = 'word';
        word.textContent= d[0];
        const objectCSS = new CSS3DObject(word);
        objectCSS.position.x = d[1][0]*xscale;
				objectCSS.position.y = d[1][1]*yscale;
				objectCSS.position.z = d[1][2]*zscale;
				scene.add( objectCSS );
    });*/

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ));
    
    const material = new THREE.PointsMaterial( { color: 0x888888 } );
    
    const points = new THREE.Points( geometry, material );
    
    scene.add( points );      
    renderer.render( scene, camera );
    renderer2.render( scene, camera );

    requestAnimationFrame(render);

    			function render(time) {
              time *= 0.001;
              controls.update();
//              geometry.rotateY(0.001);
//              alert(geometry.rotate);
				  renderer.render( scene, camera );
				  renderer2.render( scene, camera );

              requestAnimationFrame(render);          
			}

}



</script>
	  </body>
    </html>
